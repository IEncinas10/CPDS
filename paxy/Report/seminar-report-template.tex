\documentclass[a4paper, 10pt]{article}
\usepackage[a4paper, total={5.5in, 8in}]{geometry}
\usepackage[utf8]{inputenc} % Change according your file encoding
\usepackage{graphicx}
\usepackage{url}

\usepackage{xcolor}
\usepackage{todonotes}

\usepackage{listings}

\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},  
    breakatwhitespace=false,         
    basicstyle=\scriptsize,
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame=single
}



\lstset{style=mystyle}

%opening
\title{Seminar Report: Paxy}
\author{\textbf{Ignacio Encinas Rubio, Adrián Jimenez González}}
\date{\normalsize\today{}}

\begin{document}

\maketitle

%\begin{center}
  %Upload your report in PDF format.
  
  %Use this LaTeX template to format the report.
  
	%A compressed file (.tar.gz) containing all your source code files must be submitted together with this report.
%\end{center}

\section{Introduction}

The Paxy seminar consists in understanding the Paxos protocol through an Erlang implementation. First, we will develop a basic understanding of the underlying algorithm when filling the gaps in the template implementation. Later on we will build on this understanding and see the effects of different modifications such as introducing message delays, message drops, removing sorry messages and so on. Some of these modifications are specially important because they are responsible for making it impossible to guarantee a consensus in an asynchronous system.

Paxos is extensively used in production systems, so getting practical experience with it and examining how it behaves under different circumstances will prove very useful.

%\textit{Introduce in a couple of sentences the seminar and the main topic related to distributed systems it covers.}

\section{Code modifications}

   In this section we will briefly comment the code added to the template version in order to
   make the algorithm work. We will show the minimum number of lines of code possible to follow the reasoning.

  \subsection{Proposer.erl}

    \begin{minipage}{.45\textwidth}
	\begin{lstlisting}[language=erlang, caption={Template}]
	case ballot(Name, ..., ..., ..., PanelId) of  
	{ok, Value} ->
	  {Value, Round};
	abort ->
	  timer:sleep(rand:uniform(Backoff)),
	  Next = order:inc(...),
	  round(Name, (2*Backoff), ..., Proposal, Acceptors, PanelId)
	end.
	\end{lstlisting}
    \end{minipage}\hfill
    \begin{minipage}{.45\textwidth}
	\begin{lstlisting}[language=erlang, caption={Filled version}]
	case ballot(Name, Round, Proposal, Acceptors, PanelId) of
	{ok, Value} ->
	  {Value, Round};
	abort ->
	  timer:sleep(rand:uniform(Backoff)),
	  Next = order:inc(Round),
	  round(Name, (2*Backoff), Next, Proposal, Acceptors, PanelId)
	end.
	\end{lstlisting}
    \end{minipage}

    The first incomplete function is \textbf{round}. The ballot function is responsible for creating the \textit{prepare} and \textit{accept} messages from the proposer. It will need the Round in order to generate the prepare message, the Proposal to generate the accept message and the list of Acceptors for being able to send the actual messages.

    If we're not able to get our Proposal accepted we'll try again with a higher Round number after backing off for a while in order to facilitate consensus.
  

    \begin{minipage}{.45\textwidth}
	\begin{lstlisting}[language=erlang, caption={Template}]
	
  prepare(..., ...),
  Quorum = (length(...) div 2) + 1,
  MaxVoted = order:null(),
  case collect(..., ..., ..., ...) of
    {accepted, Value} ->
      accept(..., ..., ...),
      case vote(..., ...) of
        ok ->
          {ok, ...};
        abort ->
          abort
  \end{lstlisting}
    \end{minipage}\hfill
    \begin{minipage}{.45\textwidth}
	\begin{lstlisting}[language=erlang, caption={Filled version}]
	
  prepare(Round, Acceptors),
  Quorum = (length(Acceptors) div 2) + 1,
  MaxVoted = order:null(),
  case collect(Quorum, Round, MaxVoted, Proposal) of
    {accepted, Value} ->
      accept(Round, Value, Acceptors),
      case vote(Quorum, Round) of
        ok ->
          {ok, Value};
        abort ->
          abort
	\end{lstlisting}
    \end{minipage}

  For the \textit{ballot} function we need to add \textit{Round and Acceptors} as parameters for the \textit{prepare} function. With this function we send the prepare message with the Round information to the list of Accpeptors. 

  In the next step, we need is calculate the necessary votes to achieve consensus, which is calculated as the number of Acceptors divided by 2, plus 1.

  The parameters of \textit{collect} function must be Quorum in order to know if we achieve the consensus, and Round, MaxVoted and Proposal. In case of this function returns an accepted (also called \textit{promise} on the diagram) we call the \textit{accept} function with \textit{Round, Value, Acceptors} values as parameters to send the accept message. 

  Following that function, we call \textit{vote} fuction inside of a case statement with the Quorum and the Round, in case we recieve an ok the function will return \textit{\{ok, Value\}}.


    \begin{minipage}{.45\textwidth}
	\begin{lstlisting}[language=erlang, caption={Template}]
	
collect(N, Round, MaxVoted, Proposal) ->
  receive 
    {promise, Round, _, na} ->
      collect(..., ..., ..., ...);
    {promise, Round, Voted, Value} ->
      case order:gr(..., ...) of
        true ->
          collect(..., ..., ..., ...);
        false ->
          collect(..., ..., ..., ...)
      end;
    {promise, _, _,  _} ->
      collect(N, Round, MaxVoted, Proposal);
    {sorry, {prepare, Round}} ->
      collect(..., ..., ..., ...);
    {sorry, _} ->
      collect(N, Round, MaxVoted, Proposal)
  after ?timeout ->
    abort
  end.
  \end{lstlisting}
    \end{minipage}\hfill
    \begin{minipage}{.45\textwidth}
	\begin{lstlisting}[language=erlang, caption={Filled version}]
	
collect(N, Round, MaxVoted, Proposal) ->
  receive 
    {promise, Round, _, na} ->
      collect(N-1, Round, MaxVoted, Proposal);
    {promise, Round, Voted, Value} ->
      case order:gr(Voted, MaxVoted) of
        true ->
          collect(N-1, Round, Voted, Value);
        false ->
          collect(N-1, Round, MaxVoted, Proposal)
      end;
    {promise, _, _,  _} ->
      collect(N, Round, MaxVoted, Proposal);
    {sorry, {prepare, Round}} ->
      collect(N, Round, MaxVoted, Proposal);
    {sorry, _} ->
      collect(N, Round, MaxVoted, Proposal)
  after ?timeout ->
    abort
  end.
	\end{lstlisting}
    \end{minipage}

\todo[inline]{Terminar cuando TODO esté hecho}


    \begin{minipage}{.45\textwidth}
	\begin{lstlisting}[language=erlang, caption={Template}]
	
vote(N, Round) ->
  receive
    {vote, Round} ->
      vote(..., ...);
    {vote, _} ->
      vote(N, Round);
    {sorry, {accept, Round}} ->
      vote(..., ...);
    {sorry, _} ->
      vote(N, Round)
  after ?timeout ->
    abort
  end.
  \end{lstlisting}
    \end{minipage}\hfill
    \begin{minipage}{.45\textwidth}
	\begin{lstlisting}[language=erlang, caption={Filled version}]
	
vote(N, Round) ->
  receive
    {vote, Round} ->
      vote(N-1, Round);
    {vote, _} ->
      vote(N, Round);
    {sorry, {accept, Round}} ->
      vote(N, Round);
    {sorry, _} ->
      vote(N, Round)
  after ?timeout ->
    abort
  end.
	\end{lstlisting}
    \end{minipage}

  In the \textit{vote} function we expect to recieve a vote or sorry message from the Acceptors. In this function we define the behavior depending what we receive. 
  
  \begin{itemize}
    \item In case of receive a vote like \textit{\{vote, Round\}}, we subsctact 1 to the votes necessary for consensus (\textit{N}) to the next vote function with the same Round. 

    \item If we receive \textit{\{sorry, \{accept, Round\}\}} that means that the vote was rejected and we keep trying, so we do not substract nothing to the number of votes remaining for achieve consensus on the next vote function, passing N and Round again as parameters.
  \end{itemize}
    
    



\section{Experiments}
\textit{Provide evidence of the experiments you did (e.g., use screenshots) and discuss the results you got. In addition, you may provide figures or tables with experimental results of the system evaluation. For each seminar, we will provide you with some guidance on which kind of evaluation you should do.}

\subsection{Introducing delays in the promise and vote messages}

\subsubsection{Does the algorithm still terminate? Does it require more rounds? How does the impact of the message delays depend on the value of the timout at the proposer?}

\subsection{Avoid sending sorry messages}

\subsubsection{Could you come to an agreement when sorry messages are not sent?}

\subsection{Try randomly dropping promise and vote messages in the acceptor}

\subsubsection{How does the drop ratio affect the number of rounds required to reach consensus?}

\subsection{Try increasing the number of acceptors and proposers}

\subsubsection{What is the impact of having more acceptors while keeping the number of proposers?}

\subsection{Adapt the paxy module to create the proposers and acceptors in a remote Erlang instance}



\section{Fault tolerance}

\subsection{Experiments}

\section{Improvement based on sorry messages}

\subsection{Experiments}

\section{Open questions}

\textit{Try to answer all the open questions in the documentation. When possible, do experiments to support your answers.}

\section{Personal opinion}

\textit{Provide your personal opinion of the seminar, indicating whether it should be included in next year's course or not.}

\end{document}
